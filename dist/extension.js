(()=>{"use strict";var e={3:e=>{e.exports=require("path")},265:function(e,n,r){var s,o=this&&this.__createBinding||(Object.create?function(e,n,r,s){void 0===s&&(s=r);var o=Object.getOwnPropertyDescriptor(n,r);o&&!("get"in o?!n.__esModule:o.writable||o.configurable)||(o={enumerable:!0,get:function(){return n[r]}}),Object.defineProperty(e,s,o)}:function(e,n,r,s){void 0===s&&(s=r),e[s]=n[r]}),t=this&&this.__setModuleDefault||(Object.create?function(e,n){Object.defineProperty(e,"default",{enumerable:!0,value:n})}:function(e,n){e.default=n}),a=this&&this.__importStar||(s=function(e){return s=Object.getOwnPropertyNames||function(e){var n=[];for(var r in e)Object.prototype.hasOwnProperty.call(e,r)&&(n[n.length]=r);return n},s(e)},function(e){if(e&&e.__esModule)return e;var n={};if(null!=e)for(var r=s(e),a=0;a<r.length;a++)"default"!==r[a]&&o(n,e,r[a]);return t(n,e),n});Object.defineProperty(n,"__esModule",{value:!0}),n.activate=function(e){let n=i.commands.registerCommand("expressjet.createBoilerplate",async()=>{const e=i.workspace.workspaceFolders;if(!e||0===e.length)return void i.window.showErrorMessage("No folder is open in the current VS Code window.");const n=e[0].uri.fsPath,r=await i.window.showInputBox({prompt:'Enter your project name (e.g., "my-api-backend")',placeHolder:"my-express-app",value:u.basename(n)});if(!r)return void i.window.showInformationMessage("Boilerplate generation cancelled. Project name is required.");const s=await i.window.showQuickPick(["npm","yarn"],{placeHolder:"Choose your preferred package manager",canPickMany:!1});if(!s)return void i.window.showInformationMessage("Boilerplate generation cancelled. Package manager choice is required.");const o=await i.window.showQuickPick(["CommonJS (require/module.exports)","ES Modules (import/export)"],{placeHolder:"Choose your module system",canPickMany:!1});if(!o)return void i.window.showInformationMessage("Boilerplate generation cancelled. Module system choice is required.");const t="ES Modules (import/export)"===o,a=t?"mjs":"js",l=t?'"type": "module",':"",d=await i.window.showQuickPick(["Yes","No"],{placeHolder:"Include Authentication (Email/Password with JWT)?",canPickMany:!1});if(void 0===d)return void i.window.showInformationMessage("Boilerplate generation cancelled. Authentication choice is required.");const p="Yes"===d,m=u.join(n,"src"),h=["src","src/config","src/controllers","src/models","src/routes","src/middlewares","src/utils"];try{h.forEach(e=>c.mkdirSync(u.join(n,e),{recursive:!0})),(()=>{const e=t?`\nimport express from 'express';\nimport exampleRoute from './routes/example.route.${a}';\n${p?`import authRoute from './routes/auth.route.${a}';`:""}\n\nconst app = express();\n\napp.use(express.json());\n\n// Main routes\napp.use('/api/example', exampleRoute);\n${p?"app.use('/api/auth', authRoute);":""}\n\napp.get('/', (req, res) => {\n    res.send('API is running...');\n});\n\nexport default app;\n`.trim():`\nconst express = require('express');\nconst exampleRoute = require('./routes/example.route');\n${p?"const authRoute = require('./routes/auth.route');":""}\n\nconst app = express();\n\napp.use(express.json());\n\n// Main routes\napp.use('/api/example', exampleRoute);\n${p?"app.use('/api/auth', authRoute);":""}\n\napp.get('/', (req, res) => {\n    res.send('API is running...');\n});\n\nmodule.exports = app;\n`.trim();c.writeFileSync(u.join(m,`app.${a}`),e);const o=t?`\nimport app from './src/app.${a}';\nimport dotenv from 'dotenv';\nimport connectDB from './src/config/db.${a}';\n\ndotenv.config();\n\nconst PORT = process.env.PORT || 5000;\n\n// Connect to database\nconnectDB();\n\nconst server = app.listen(PORT, () => {\n    console.log(\`Server running on port \${PORT}\`);\n});\n\n// Handle unhandled promise rejections\nprocess.on('unhandledRejection', (err, promise) => {\n    console.log(\`Error: \${err.message}\`);\n    // Close server & exit process\n    server.close(() => process.exit(1));\n});\n`.trim():"\nconst app = require('./src/app');\nconst dotenv = require('dotenv');\nconst connectDB = require('./src/config/db');\n\ndotenv.config();\n\nconst PORT = process.env.PORT || 5000;\n\n// Connect to database\nconnectDB();\n\nconst server = app.listen(PORT, () => {\n    console.log(`Server running on port ${PORT}`);\n});\n\n// Handle unhandled promise rejections\nprocess.on('unhandledRejection', (err, promise) => {\n    console.log(`Error: ${err.message}`);\n    // Close server & exit process\n    server.close(() => process.exit(1));\n});\n".trim();c.writeFileSync(u.join(n,`server.${a}`),o);const i=t?"\nimport mongoose from 'mongoose';\nimport dotenv from 'dotenv';\n\ndotenv.config();\n\nconst connectDB = async () => {\n    try {\n        await mongoose.connect(process.env.MONGO_URI);\n        console.log('MongoDB Connected');\n    } catch (err) {\n        console.error(err.message);\n        process.exit(1);\n    }\n};\n\nexport default connectDB;\n".trim():"\nconst mongoose = require('mongoose');\nrequire('dotenv').config();\n\nconst connectDB = async () => {\n    try {\n        await mongoose.connect(process.env.MONGO_URI);\n        console.log('MongoDB Connected');\n    } catch (err) {\n        console.error(err.message);\n        process.exit(1);\n    }\n};\n\nmodule.exports = connectDB;\n".trim();c.writeFileSync(u.join(m,"config",`db.${a}`),i);const d=`PORT=5000\nMONGO_URI=mongodb://localhost:27017/${r.toLowerCase().replace(/\s/g,"-")}-db${p?"\nJWT_SECRET=YOUR_SUPER_SECRET_KEY\nJWT_EXPIRES_IN=1h":""}`;c.writeFileSync(u.join(n,".env"),d),c.writeFileSync(u.join(n,".gitignore"),"node_modules/\n.env\n.vscode/\nbuild/");const h=`\n# ${r} - Express + MongoDB Boilerplate\n\n## üîß Installation\n\n\`\`\`bash\n${s} install\n\`\`\`\n\n## üöÄ Run the server\n\n\`\`\`bash\n${"npm"===s?"npm run dev":"yarn dev"}\n\`\`\`\n\n## üìÅ Folder Structure\n\n- \`server.${a}\`: Main server entry point\n- \`src/config\`: Database configuration\n- \`src/controllers\`: Contains business logic for routes\n- \`src/models\`: Mongoose schemas and models\n- \`src/routes\`: API routes definitions\n- \`src/middlewares\`: Custom Express middlewares\n- \`src/utils\`: Helper functions, error handling, etc.\n\n---\n\n## üí° Quick Start Example\n\nThis boilerplate includes a basic example for a "User" resource.\n\n### Model: \`src/models/User.model.${a}\`\n\n\`\`\`${t?"js":"javascript"}\n${t?"import mongoose from 'mongoose';\nimport bcrypt from 'bcryptjs';\nimport jwt from 'jsonwebtoken';":"const mongoose = require('mongoose');\nconst bcrypt = require('bcryptjs');\nconst jwt = require('jsonwebtoken');"}\n\nconst userSchema = new mongoose.Schema({\n    name: {\n        type: String,\n        required: true,\n    },\n    email: {\n        type: String,\n        required: true,\n        unique: true,\n    },\n    ${p?"password: {\n        type: String,\n        required: true,\n    },\n    role: {\n        type: String,\n        enum: ['user', 'admin'],\n        default: 'user',\n    },":""}\n    createdAt: {\n        type: Date,\n        default: Date.now,\n    },\n});\n\n${p?"\n// Hash password before saving\nuserSchema.pre('save', async function(next) {\n    if (!this.isModified('password')) {\n        next();\n    }\n    const salt = await bcrypt.genSalt(10);\n    this.password = await bcrypt.hash(this.password, salt);\n});\n\n// Compare password method\nuserSchema.methods.matchPassword = async function(enteredPassword) {\n    return await bcrypt.compare(enteredPassword, this.password);\n};\n\n// Generate JWT token\nuserSchema.methods.getSignedJwtToken = function() {\n    return jwt.sign({ id: this._id }, process.env.JWT_SECRET, {\n        expiresIn: process.env.JWT_EXPIRES_IN,\n    });\n};\n":""}\n\n${t?"export default mongoose.model('User', userSchema);":"module.exports = mongoose.model('User', userSchema);"}\n\`\`\`\n\n### Controller: \`src/controllers/example.controller.${a}\`\n\n\`\`\`${t?"js":"javascript"}\n${t?`import User from '../models/User.model.${a}';`:"const User = require('../models/User.model');"}\n\n${t?"export const getAllUsers = async (req, res) => {":"exports.getAllUsers = async (req, res) => {"}\n    try {\n        const users = await User.find();\n        res.json(users);\n    } catch (error) {\n        console.error(error);\n        res.status(500).json({ message: 'Server Error' });\n    }\n};\n\n${t?"export const createUser = async (req, res) => {":"exports.createUser = async (req, res) => {"}\n    const { name, email ${p?", password":""} } } = req.body;\n    try {\n        const newUser = new User({ name, email ${p?", password":""} });\n        await newUser.save();\n        res.status(201).json(newUser);\n    } catch (error) {\n        console.error(error);\n        res.status(500).json({ message: 'Server Error' });\n    }\n};\n\`\`\`\n\n### Route: \`src/routes/example.route.${a}\`\n\n\`\`\`${t?"js":"javascript"}\n${t?`import express from 'express';\nimport { getAllUsers, createUser } from '../controllers/example.controller.${a}';\n${p?`import { protect } from '../middlewares/auth.middleware.${a}';`:""}`:"const express = require('express');\nconst { getAllUsers, createUser } = require('../controllers/example.controller');\n"+(p?"const { protect } = require('../middlewares/auth.middleware');":"")}\n\nconst router = express.Router();\n\nrouter.get('/', getAllUsers);\nrouter.post('/', createUser);\n\n// Example of a protected route\n${p?"router.get('/protected-example', protect, (req, res) => {\n    res.json({ message: 'This is a protected route!', user: req.user });\n});":""}\n\n${t?"export default router;":"module.exports = router;"}\n\`\`\`\n\n${p?'\n## üîê Authentication (Email/Password with JWT)\n\nIf you chose to include authentication, your project is set up with:\n\n* **User Model:** Includes `email`, `password` (hashed), and `role` fields.\n* **Registration:** `POST /api/auth/register`\n* **Login:** `POST /api/auth/login`\n* **Token Generation:** JWTs are issued upon successful registration/login.\n* **Protected Routes:** A `protect` middleware to safeguard routes (e.g., `/api/example/protected-example`).\n\n### Authentication API Endpoints\n\n* **Register User:**\n    * `POST /api/auth/register`\n    * **Body:** `{ "name": "...", "email": "...", "password": "..." }`\n    * **Response:** JWT token and user details.\n\n* **Login User:**\n    * `POST /api/auth/login`\n    * **Body:** `{ "email": "...", "password": "..." }`\n    * **Response:** JWT token and user details.\n\n* **Access Protected Route (Example):**\n    * `GET /api/example/protected-example`\n    * **Headers:** `Authorization: Bearer <YOUR_JWT_TOKEN>`\n    * **Response:** Access granted message and user data.\n\n### Environment Variables for Auth\n\nMake sure to set these in your `.env` file:\n\n```\nJWT_SECRET=YOUR_SUPER_SECRET_KEY_REPLACE_THIS\nJWT_EXPIRES_IN=1h\n```\n':""}\n\n---\n\n## üôè Contribution & Support\n\nFound an issue or have a feature request? Feel free to open an issue or submit a pull request on our GitHub repository:\n\n* **Repository:** [https://github.com/IamNishant51/Backend-Folder-str-Generator](https://github.com/IamNishant51/Backend-Folder-str-Generator)\n* **Issues:** [https://github.com/IamNishant51/Backend-Folder-str-Generator/issues](https://github.com/IamNishant51/Backend-Folder-str-Generator/issues)\n\n## üìÑ License\n\nThis extension is licensed under the ISC License.\n\n---\n\n**Crafted with üíñ by Nishant Unavane ‚Äî The Web Architect**\n\n---\n`.trim();c.writeFileSync(u.join(n,"README.md"),h);let w='"dotenv": "^16.0.3",\n\t\t"express": "^4.18.2",\n\t\t"mongoose": "^7.6.0"';p&&(w+=',\n\t\t"bcryptjs": "^2.4.3",\n\t\t"jsonwebtoken": "^9.0.2"');const g=`\n{\n    "name": "${r.toLowerCase().replace(/\s/g,"-")}",\n    "version": "1.0.0",\n    "description": "A modern Express.js and MongoDB backend boilerplate.",\n    ${l}\n    "main": "server.${a}", \n    "scripts": {\n        "start": "node server.${a}", \n        "dev": "nodemon server.${a}" \n    },\n    "keywords": [\n        "express",\n        "mongodb",\n        "boilerplate",\n        "api"\n    ],\n    "author": "Nishant ‚Äî The Web Architect",\n    "license": "ISC",\n    "dependencies": {\n        ${w}\n    },\n    "devDependencies": {\n        "nodemon": "^3.0.1"\n    }\n}\n`.trim();c.writeFileSync(u.join(n,"package.json"),g);const f=t?`\nimport mongoose from 'mongoose';\nimport bcrypt from 'bcryptjs';\nimport jwt from 'jsonwebtoken';\n\nconst userSchema = new mongoose.Schema({\n    name: {\n        type: String,\n        required: true,\n    },\n    email: {\n        type: String,\n        required: true,\n        unique: true,\n    },\n    ${p?"password: {\n        type: String,\n        required: true,\n    },\n    role: {\n        type: String,\n        enum: ['user', 'admin'],\n        default: 'user',\n    },":""}\n    createdAt: {\n        type: Date,\n        default: Date.now,\n    },\n});\n\n${p?"\n// Hash password before saving\nuserSchema.pre('save', async function(next) {\n    if (!this.isModified('password')) {\n        next();\n    }\n    const salt = await bcrypt.genSalt(10);\n    this.password = await bcrypt.hash(this.password, salt);\n});\n\n// Compare password method\nuserSchema.methods.matchPassword = async function(enteredPassword) {\n    return await bcrypt.compare(enteredPassword, this.password);\n};\n\n// Generate JWT token\nuserSchema.methods.getSignedJwtToken = function() {\n    return jwt.sign({ id: this._id }, process.env.JWT_SECRET, {\n        expiresIn: process.env.JWT_EXPIRES_IN,\n    });\n};\n":""}\n\nexport default mongoose.model('User', userSchema);\n`.trim():`\nconst mongoose = require('mongoose');\nconst bcrypt = require('bcryptjs');\nconst jwt = require('jsonwebtoken');\n\nconst userSchema = new mongoose.Schema({\n    name: {\n        type: String,\n        required: true,\n    },\n    email: {\n        type: String,\n        required: true,\n        unique: true,\n    },\n    ${p?"password: {\n        type: String,\n        required: true,\n    },\n    role: {\n        type: String,\n        enum: ['user', 'admin'],\n        default: 'user',\n    },":""}\n    createdAt: {\n        type: Date,\n        default: Date.now,\n    },\n});\n\n${p?"\n// Hash password before saving\nuserSchema.pre('save', async function(next) {\n    if (!this.isModified('password')) {\n        next();\n    }\n    const salt = await bcrypt.genSalt(10);\n    this.password = await bcrypt.hash(this.password, salt);\n});\n\n// Compare password method\nuserSchema.methods.matchPassword = async function(enteredPassword) {\n    return await bcrypt.compare(enteredPassword, this.password);\n};\n\n// Generate JWT token\nuserSchema.methods.getSignedJwtToken = function() {\n    return jwt.sign({ id: this._id }, process.env.JWT_SECRET, {\n        expiresIn: process.env.JWT_EXPIRES_IN,\n    });\n};\n":""}\n\nmodule.exports = mongoose.model('User', userSchema);\n`.trim();c.writeFileSync(u.join(m,"models",`User.model.${a}`),f);const x=t?`\nimport User from '../models/User.model.${a}';\n\nexport const getAllUsers = async (req, res) => {\n    try {\n        const users = await User.find();\n        res.json(users);\n    } catch (error) {\n        console.error(error);\n        res.status(500).json({ message: 'Server Error' });\n    }\n};\n\nexport const createUser = async (req, res) => {\n    const { name, email ${p?", password":""} } = req.body;\n    try {\n        const newUser = new User({ name, email ${p?", password":""} });\n        await newUser.save();\n        res.status(201).json(newUser);\n    } catch (error) {\n        console.error(error);\n        res.status(500).json({ message: 'Server Error' });\n    }\n};\n`.trim():`\nconst User = require('../models/User.model');\n\nexports.getAllUsers = async (req, res) => {\n    try {\n        const users = await User.find();\n        res.json(users);\n    } catch (error) {\n        console.error(error);\n        res.status(500).json({ message: 'Server Error' });\n    }\n};\n\nexports.createUser = async (req, res) => {\n    const { name, email ${p?", password":""} } = req.body;\n    try {\n        const newUser = new User({ name, email ${p?", password":""} });\n        await newUser.save();\n        res.status(201).json(newUser);\n    } catch (error) {\n        console.error(error);\n        res.status(500).json({ message: 'Server Error' });\n    }\n};\n`.trim();c.writeFileSync(u.join(m,"controllers",`example.controller.${a}`),x);const y=t?`\nimport express from 'express';\nimport { getAllUsers, createUser } from '../controllers/example.controller.${a}';\n${p?`import { protect } from '../middlewares/auth.middleware.${a}';`:""}\n\nconst router = express.Router();\n\nrouter.get('/', getAllUsers);\nrouter.post('/', createUser);\n\n// Example of a protected route\n${p?"router.get('/protected-example', protect, (req, res) => {\n    res.json({ message: 'This is a protected route!', user: req.user });\n});":""}\n\nexport default router;\n`.trim():`\nconst express = require('express');\nconst { getAllUsers, createUser } = require('../controllers/example.controller');\n${p?"const { protect } = require('../middlewares/auth.middleware');":""}\n\nconst router = express.Router();\n\nrouter.get('/', getAllUsers);\nrouter.post('/', createUser);\n\n// Example of a protected route\n${p?"router.get('/protected-example', protect, (req, res) => {\n    res.json({ message: 'This is a protected route!', user: req.user });\n});":""}\n\nmodule.exports = router;\n`.trim();if(c.writeFileSync(u.join(m,"routes",`example.route.${a}`),y),p){const e=t?`\nimport User from '../models/User.model.${a}';\nimport jwt from 'jsonwebtoken';\nimport bcrypt from 'bcryptjs';\n\n// Helper function to send JWT token\nconst sendTokenResponse = (user, statusCode, res) => {\n    const token = user.getSignedJwtToken();\n    const options = {\n        expires: new Date(Date.now() + process.env.JWT_EXPIRES_IN * 24 * 60 * 60 * 1000), // Convert hours to ms\n        httpOnly: true // Prevent client-side JS from accessing token\n    };\n\n    res.status(statusCode).cookie('token', token, options).json({\n        success: true,\n        token,\n        user: {\n            id: user._id,\n            name: user.name,\n            email: user.email,\n            role: user.role\n        }\n    });\n};\n\n// @desc    Register user\n// @route   POST /api/auth/register\n// @access  Public\nexport const register = async (req, res) => {\n    const { name, email, password, role } = req.body;\n\n    try {\n        // Create user\n        const user = await User.create({\n            name,\n            email,\n            password,\n            role\n        });\n\n        sendTokenResponse(user, 200, res);\n\n    } catch (err) {\n        console.error(err);\n        res.status(500).json({ success: false, error: 'Server Error or User Exists' });\n    }\n};\n\n// @desc    Login user\n// @route   POST /api/auth/login\n// @access  Public\nexport const login = async (req, res) => {\n    const { email, password } = req.body;\n\n    // Validate email & password\n    if (!email || !password) {\n        return res.status(400).json({ success: false, error: 'Please enter an email and password' });\n    }\n\n    try {\n        // Check for user\n        const user = await User.findOne({ email }).select('+password'); // Select password explicitly\n\n        if (!user) {\n            return res.status(401).json({ success: false, error: 'Invalid credentials' });\n        }\n\n        // Check if password matches\n        const isMatch = await user.matchPassword(password);\n\n        if (!isMatch) {\n            return res.status(401).json({ success: false, error: 'Invalid credentials' });\n        }\n\n        sendTokenResponse(user, 200, res);\n\n    } catch (err) {\n        console.error(err);\n        res.status(500).json({ success: false, error: 'Server Error' });\n    }\n};\n\n// @desc    Get current logged in user\n// @route   GET /api/auth/me\n// @access  Private\nexport const getMe = async (req, res) => {\n    try {\n        // req.user is set by the protect middleware\n        const user = await User.findById(req.user.id);\n        res.status(200).json({\n            success: true,\n            user\n        });\n    } catch (err) {\n        console.error(err);\n        res.status(500).json({ success: false, error: 'Server Error' });\n    }\n};\n`.trim():"\nconst User = require('../models/User.model');\nconst jwt = require('jsonwebtoken');\nconst bcrypt = require('bcryptjs');\n\n// Helper function to send JWT token\nconst sendTokenResponse = (user, statusCode, res) => {\n    const token = user.getSignedJwtToken();\n    const options = {\n        expires: new Date(Date.now() + process.env.JWT_EXPIRES_IN * 24 * 60 * 60 * 1000), // Convert hours to ms\n        httpOnly: true // Prevent client-side JS from accessing token\n    };\n\n    res.status(statusCode).cookie('token', token, options).json({\n        success: true,\n        token,\n        user: {\n            id: user._id,\n            name: user.name,\n            email: user.email,\n            role: user.role\n        }\n    });\n};\n\n// @desc    Register user\n// @route   POST /api/auth/register\n// @access  Public\nexports.register = async (req, res) => {\n    const { name, email, password, role } = req.body;\n\n    try {\n        // Create user\n        const user = await User.create({\n            name,\n            email,\n            password,\n            role\n        });\n\n        sendTokenResponse(user, 200, res);\n\n    } catch (err) {\n        console.error(err);\n        res.status(500).json({ success: false, error: 'Server Error or User Exists' });\n    }\n};\n\n// @desc    Login user\n// @route   POST /api/auth/login\n// @access  Public\nexports.login = async (req, res) => {\n    const { email, password } = req.body;\n\n    // Validate email & password\n    if (!email || !password) {\n        return res.status(400).json({ success: false, error: 'Please enter an email and password' });\n    }\n\n    try {\n        // Check for user\n        const user = await User.findOne({ email }).select('+password'); // Select password explicitly\n\n        if (!user) {\n            return res.status(401).json({ success: false, error: 'Invalid credentials' });\n        }\n\n        // Check if password matches\n        const isMatch = await user.matchPassword(password);\n\n        if (!isMatch) {\n            return res.status(401).json({ success: false, error: 'Invalid credentials' });\n        }\n\n        sendTokenResponse(user, 200, res);\n\n    } catch (err) {\n        console.error(err);\n        res.status(500).json({ success: false, error: 'Server Error' });\n    }\n};\n\n// @desc    Get current logged in user\n// @route   GET /api/auth/me\n// @access  Private\nexports.getMe = async (req, res) => {\n    try {\n        // req.user is set by the protect middleware\n        const user = await User.findById(req.user.id);\n        res.status(200).json({\n            success: true,\n            user\n        });\n    } catch (err) {\n        console.error(err);\n        res.status(500).json({ success: false, error: 'Server Error' });\n    }\n};\n".trim();c.writeFileSync(u.join(m,"controllers",`auth.controller.${a}`),e);const n=t?`\nimport express from 'express';\nimport { register, login, getMe } from '../controllers/auth.controller.${a}';\nimport { protect } from '../middlewares/auth.middleware.${a}';\n\nconst router = express.Router();\n\nrouter.post('/register', register);\nrouter.post('/login', login);\nrouter.get('/me', protect, getMe);\n\nexport default router;\n`.trim():"\nconst express = require('express');\nconst { register, login, getMe } = require('../controllers/auth.controller');\nconst { protect } = require('../middlewares/auth.middleware');\n\nconst router = express.Router();\n\nrouter.post('/register', register);\nrouter.post('/login', login);\nrouter.get('/me', protect, getMe);\n\nmodule.exports = router;\n".trim();c.writeFileSync(u.join(m,"routes",`auth.route.${a}`),n);const r=t?`\nimport jwt from 'jsonwebtoken';\nimport User from '../models/User.model.${a}';\n\n// Protect routes\nexport const protect = async (req, res, next) => {\n    let token;\n\n    if (req.headers.authorization && req.headers.authorization.startsWith('Bearer')) {\n        // Set token from Bearer token in header\n        token = req.headers.authorization.split(' ')[1];\n    }\n    // Else if using cookies, uncomment below\n    // else if (req.cookies.token) {\n    //     token = req.cookies.token;\n    // }\n\n    // Make sure token exists\n    if (!token) {\n        return res.status(401).json({ success: false, error: 'Not authorized to access this route' });\n    }\n\n    try {\n        // Verify token\n        const decoded = jwt.verify(token, process.env.JWT_SECRET);\n\n        req.user = await User.findById(decoded.id);\n\n        next();\n    } catch (err) {\n        return res.status(401).json({ success: false, error: 'Not authorized to access this route' });\n    }\n};\n\n// Grant access to specific roles\nexport const authorize = (...roles) => {\n    return (req, res, next) => {\n        if (!roles.includes(req.user.role)) {\n            return res.status(403).json({ success: false, error: \`User role \${req.user.role} is not authorized to access this route\` });\n        }\n        next();\n    };\n};\n`.trim():"\nconst jwt = require('jsonwebtoken');\nconst User = require('../models/User.model');\n\n// Protect routes\nexports.protect = async (req, res, next) => {\n    let token;\n\n    if (req.headers.authorization && req.headers.authorization.startsWith('Bearer')) {\n        // Set token from Bearer token in header\n        token = req.headers.authorization.split(' ')[1];\n    }\n    // Else if using cookies, uncomment below\n    // else if (req.cookies.token) {\n    //     token = req.cookies.token;\n    // }\n\n    // Make sure token exists\n    if (!token) {\n        return res.status(401).json({ success: false, error: 'Not authorized to access this route' });\n    }\n\n    try {\n        // Verify token\n        const decoded = jwt.verify(token, process.env.JWT_SECRET);\n\n        req.user = await User.findById(decoded.id);\n\n        next();\n    } catch (err) {\n        return res.status(401).json({ success: false, error: 'Not authorized to access this route' });\n    }\n};\n\n// Grant access to specific roles\nexports.authorize = (...roles) => {\n    return (req, res, next) => {\n        if (!roles.includes(req.user.role)) {\n            return res.status(403).json({ success: false, error: `User role ${req.user.role} is not authorized to access this route` });\n        }\n        next();\n    };\n};\n".trim();c.writeFileSync(u.join(m,"middlewares",`auth.middleware.${a}`),r)}})(),i.window.showInformationMessage(`‚úÖ Express backend boilerplate for "${r}" generated!`);const e=i.window.createTerminal(`Install Dependencies (${s})`);e.show(),e.sendText(`${s} install`),e.sendText("exit"),i.window.showInformationMessage(`Dependencies are being installed with ${s}.`);const o="Open README.md",d="Show in Explorer";i.window.showInformationMessage("Your Express.js backend is ready!",o,d).then(e=>{e===o?i.workspace.openTextDocument(u.join(n,"README.md")).then(e=>{i.window.showTextDocument(e)}):e===d&&i.commands.executeCommand("revealFileInOS",i.Uri.file(n))})}catch(e){i.window.showErrorMessage(`‚ùå Error creating boilerplate: ${e.message}`)}});e.subscriptions.push(n)},n.deactivate=function(){};const i=a(r(398)),c=a(r(383)),u=a(r(3))},383:e=>{e.exports=require("fs")},398:e=>{e.exports=require("vscode")}},n={},r=function r(s){var o=n[s];if(void 0!==o)return o.exports;var t=n[s]={exports:{}};return e[s].call(t.exports,t,t.exports,r),t.exports}(265);module.exports=r})();
//# sourceMappingURL=extension.js.map